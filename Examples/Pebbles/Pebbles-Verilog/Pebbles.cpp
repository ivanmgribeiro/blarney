#include "VPebbles.h"
#include <verilated.h>

#include <fstream>
#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <unistd.h>
#include "socket_packet_utils.c"
#include <stdlib.h>
#if VM_TRACE
#include <verilated_vcd_c.h>
#endif

#define MEM_BASE_BYTES 0x80000000
#define MEM_BASE_WORDS 0x20000000
#define MEM_SIZE_BYTES 0x10000
#define MEM_SIZE_WORDS 0x2000000/4

struct RVFI_DII_Execution_Packet {
    std::uint64_t rvfi_order : 64;      // [00 - 07] Instruction number:      INSTRET value after completion.
    std::uint64_t rvfi_pc_rdata : 64;   // [08 - 15] PC before instr:         PC for current instruction
    std::uint64_t rvfi_pc_wdata : 64;   // [16 - 23] PC after instr:          Following PC - either PC + 4 or jump/trap target.
    std::uint64_t rvfi_insn : 64;       // [24 - 31] Instruction word:        32-bit command value.
    std::uint64_t rvfi_rs1_data : 64;   // [32 - 39] Read register values:    Values as read from registers named
    std::uint64_t rvfi_rs2_data : 64;   // [40 - 47]                          above. Must be 0 if register ID is 0.
    std::uint64_t rvfi_rd_wdata : 64;   // [48 - 55] Write register value:    MUST be 0 if rd_ is 0.
    std::uint64_t rvfi_mem_addr : 64;   // [56 - 63] Memory access addr:      Points to byte address (aligned if define
                                        //                                      is set). *Should* be straightforward.
                                        //                                      0 if unused.
    std::uint64_t rvfi_mem_rdata : 64;  // [64 - 71] Read data:               Data read from mem_addr (i.e. before write)
    std::uint64_t rvfi_mem_wdata : 64;  // [72 - 79] Write data:              Data written to memory by this command.
    std::uint8_t rvfi_mem_rmask : 8;    // [80]      Read mask:               Indicates valid bytes read. 0 if unused.
    std::uint8_t rvfi_mem_wmask : 8;    // [81]      Write mask:              Indicates valid bytes written. 0 if unused.
    std::uint8_t rvfi_rs1_addr : 8;     // [82]      Read register addresses: Can be arbitrary when not used,
    std::uint8_t rvfi_rs2_addr : 8;     // [83]                          otherwise set as decoded.
    std::uint8_t rvfi_rd_addr : 8;      // [84]      Write register address:  MUST be 0 if not used.
    std::uint8_t rvfi_trap : 8;         // [85] Trap indicator:          Invalid decode, misaligned access or
                                        //                                      jump command to misaligned address.
    std::uint8_t rvfi_halt : 8;         // [86] Halt indicator:          Marks the last instruction retired 
                                        //                                      before halting execution.
    std::uint8_t rvfi_intr : 8;         // [87] Trap handler:            Set for first instruction in trap handler.     
};

struct RVFI_DII_Instruction_Packet {
    std::uint32_t dii_insn : 32;      // [0 - 3] Instruction word: 32-bit instruction or command. The lower 16-bits
                                      // may decode to a 16-bit compressed instruction.
    std::uint16_t dii_time : 16;      // [5 - 4] Time to inject token.  The difference between this and the previous
                                      // instruction time gives a delay before injecting this instruction.
                                      // This can be ignored for models but gives repeatability for implementations
                                      // while shortening counterexamples.
    std::uint8_t dii_cmd : 8;         // [6] This token is a trace command.  For example, reset device under test.
    std::uint8_t padding : 8;         // [7]
};

RVFI_DII_Execution_Packet readRVFI(VPebbles *top, bool signExtend);
void sendReturnTrace(std::vector<RVFI_DII_Execution_Packet> &returnTrace, unsigned long long socket);


// Generated by Blarney
#include <verilated.h>
#include "VPebbles.h"
vluint64_t main_time = 0;
// Called by $time in Verilog
double sc_time_stamp () {
  return main_time;
}

int main(int argc, char** argv, char** env) {

    if (argc != 3) {
        std::cerr << "wrong number of args" << std::endl;
        exit(-1);
    }

    Verilated::commandArgs(argc, argv);
    VPebbles* top = new VPebbles;

    // set up tracing
    #if VM_TRACE
    std::cout << "tracing" << std::endl;
    Verilated::traceEverOn(true);
    VerilatedVcdC trace_obj;
    top->trace(&trace_obj, 99);
    trace_obj.open("vlt_d.vcd");
    #endif

    // initialize the socket with the input parameters
    unsigned long long socket = serv_socket_create(argv[1], std::atoi(argv[2]));
    serv_socket_init(socket);

    // set up initial core inputs
    top->clock = 0;
    top->reset = 1;
    top->eval();

    top->reset = 0;
    top->eval();

    int received = 0;
    int in_count = 0;
    int out_count = 0;

    int timeout_counter = 0;

    char recbuf[sizeof(RVFI_DII_Instruction_Packet) + 1] = {0};
    std::vector<RVFI_DII_Instruction_Packet> instructions;
    std::vector<RVFI_DII_Execution_Packet> returntrace;
    while (1) {
        // send back execution trace if the number of instructions that have come out is equal to the
        // number that have gone in
        //if (returntrace.size() > 0 && in_count == out_count) {
        //
        // TODO increase threshold to bulk-send instructions
        if (returntrace.size() > 0) {
            sendReturnTrace(returntrace, socket);
        }


        RVFI_DII_Instruction_Packet *packet;
        //while (in_count >= received) {
        if (in_count >= received) {
            // try to receive a packet

                serv_socket_getN((unsigned int *) recbuf, socket, sizeof(RVFI_DII_Instruction_Packet));

                // the last byte received will be 0 if our attempt to receive a packet was successful
                while (recbuf[8] == 0) {
                    packet = (RVFI_DII_Instruction_Packet *) recbuf;

                    instructions.push_back(*packet);
                    received++;
                    serv_socket_getN((unsigned int *) recbuf, socket, sizeof(RVFI_DII_Instruction_Packet));
                    //std::cout << "received packet" << std::endl;
                    // sleep for 0.1ms before trying to receive another instruction
                    usleep(100);
                }

        }

        // need to clock the core while there are still instructions in the buffer


        // core clocking
        // conditional
        if (  received > 0
           && (   in_count - out_count > 0 // there are instructions still in the pipeline
               || in_count < received )) {       // this is the first instruction




            // read rvfi data and add packet to list of packets to send
            // the condition to read data here is that there is an rvfi valid signal
            // this deals with counting instructions that the core has finished executing
            if (top->out_rvfi_dii_data_rvfi_data_rvfi_valid || top->reset) {
                std::cout << "instruction 0x"
                          << std::hex
                          << (int)top->out_rvfi_dii_data_rvfi_data_rvfi_insn
                          << " successfully retired"
                          << std::endl;
                RVFI_DII_Execution_Packet execpacket = readRVFI(top, false);

                returntrace.push_back(execpacket);

                out_count++;

                timeout_counter = 0;
            }
            // perform instruction read
            // returns instructions from the DII input from TestRIG
            //top->int_peek = instructions[in_count].dii_insn;

            // check if an instruction was consumed last cycle
            //std::cout << "reset value: " << (int) top->reset << std::endl;
            top->in_insnInput_canPeek = 0;
            //if (top->in_insnInput_consume_en || top->reset) {
            //    //std::cout << "core consumed :" << std::to_string(instructions[in_count].dii_insn) << std::endl;
            //    std::cout << "consume_en: " << (int) top->in_insnInput_consume_en << std::endl;
            //    in_count++;
            //}

            std::cout << "in_count: " << in_count
                      << " || out_count : " << out_count
                      << " || received: " << received << std::endl;


            //std::cout << "array size: " << instructions.size() << " in_count: " << in_count << std::endl;

            // feed in a new instruction and tell it if it's available
            top->in_insnInput_peek = instructions[in_count].dii_insn;
            //std::cout << "setting value: " << std::hex << (int)instructions[in_count].dii_insn << std::endl;
            top->reset = 0;
            if (in_count < received && instructions[in_count].dii_cmd) {
                top->in_insnInput_canPeek = 1;
            } else {
                if (in_count == out_count && in_count < received) {
                    top->reset = 1;

                    std::cout << "reset" << std::endl;
                }
            }


            if (top->out_rvfi_dii_data_flush4) {
                // a flush has occurred in stage 4
                in_count = out_count + 1;
            } else if (top->out_rvfi_dii_data_flush) {
                // a flush has occurred in stage 3
                // need to go back to the correct instruction
                //std::cout << "values when calculating flush: "
                //          << "go4: "
                //          << (int) top->out_rvfi_dii_data_go4
                //          << std::endl;
                in_count = out_count + ((int) top->out_rvfi_dii_data_go4) + 1;
            }


            // read rvfi data and add packet to list of packets to send
            // the condition to read data here is that the core has just been reset
            // this deals with counting reset instruction packets from TestRIG
            //std::cout << in_count - out_count << ", " << (top->reset > 0) << std::endl;
            //if (in_count - out_count >= 0 && top->reset) {
            //    RVFI_DII_Execution_Packet execpacket = readRVFI(top, false);

            //    returntrace.push_back(execpacket);

            //    out_count++;
            //    timeout_counter = 0;
            //}


            top->eval();

            if ((top->in_insnInput_consume_en || top->reset) && in_count <= received) {
                //std::cout << "core consumed :" << std::to_string(instructions[in_count].dii_insn) << std::endl;
                //std::cout << "consume_en: " << (int) top->in_insnInput_consume_en << std::endl;
                in_count++;
            }

            top->clock = 1;
            top->eval();

            // tracing
            #if VM_TRACE
            trace_obj.dump(main_time);
            trace_obj.flush();
            main_time++;
            #endif


            top->clock = 0;
            top->eval();

            if (top->reset) {
                //std::cout << "creating new core" << std::endl;
                top->clock = 1;
                top->eval();
                top->clock = 0;
                top->eval();

                
                delete top;
                top = new VPebbles;
                for (int i = 0; i < 3; i++) {
                    top->reset = 1;
                    top->clock = 1;
                    top->eval();
                    top->clock = 0;
                    top->eval();
                }


                #if VM_TRACE
                top->trace(&trace_obj, 99);
                std::string filename = "vtl_d";
                filename += std::to_string(out_count);
                filename += ".vcd";
                trace_obj.open(filename.c_str());
                #endif
                
            }

            // tracing
            #if VM_TRACE
            trace_obj.dump(main_time);
            trace_obj.flush();
            #endif

            main_time++;

            timeout_counter++;

            // if we have a large difference between the number of instructions that have gone in
            // and the number that have come out, something's gone wrong; exit the program
            if (in_count - out_count > 10 || timeout_counter > 50) {
                top->reset = 1;
                
                for (int i = out_count; i <= received; i++) {
                    if (!instructions[i].dii_cmd) {
                        out_count = i;
                        in_count = i;
                        break;
                    }
                }

                timeout_counter = 0;

                std::cout << "TIMED OUT" << std::endl;
                std::cout << "TIMED OUT" << std::endl;
                std::cout << "TIMED OUT" << std::endl;
                std::cout << "TIMED OUT" << std::endl;
                std::cout << "TIMED OUT" << std::endl;
                std::cout << "TIMED OUT" << std::endl;
                std::cout << "TIMED OUT" << std::endl;
                //break;
            }
        }

    }

    std::cout << "finished" << std::endl << std::flush;
    delete top;
    exit(0);
}


// send the return trace that is passed in over the socket that is passed in
void sendReturnTrace(std::vector<RVFI_DII_Execution_Packet> &returntrace, unsigned long long socket) {
    const int BULK_SEND = 50;

    std::cout << "sending trace" << std::endl;

    if (returntrace.size() > 0) {
        int tosend = 1;
        for (int i = 0; i < returntrace.size(); i+=tosend) {
            tosend = 1;
            RVFI_DII_Execution_Packet sendarr[BULK_SEND];
            sendarr[0] = returntrace[i];

            // bulk send if possible
            if (returntrace.size() - i > BULK_SEND) {
                tosend = BULK_SEND;
                for (int j = 0; j < tosend; j++) {
                    sendarr[j] = returntrace[i+j];
                }
            }

            // loop to make sure that the packet has been properly sent
            while (
                !serv_socket_putN(socket, sizeof(RVFI_DII_Execution_Packet) * tosend, (unsigned int *) sendarr)
            ) {
                //std::cout << "sending" << std::endl;
                // empty
            }
        }
        //std::cout << "clearing" << std::endl;
        returntrace.clear();
    }
}

RVFI_DII_Execution_Packet readRVFI(VPebbles *top, bool signExtend) {
    unsigned long long signExtension;
    if (signExtend) {
        signExtension = 0xFFFFFFFF00000000;
    } else {
        signExtension = 0x0000000000000000;
    }

    /*
    RVFI_DII_Execution_Packet execpacket = {
        .rvfi_order = top->rvfi_order,
        .rvfi_pc_rdata = top->rvfi_pc_rdata     | ((top->rvfi_pc_rdata & 0x80000000) ? signExtension : 0),
        .rvfi_pc_wdata = top->rvfi_pc_wdata     | ((top->rvfi_pc_wdata & 0x80000000) ? signExtension : 0),
        .rvfi_insn = top->rvfi_insn             | ((top->rvfi_insn & 0x80000000) ? signExtension : 0 ),
        .rvfi_rs1_data = top->rvfi_rs1_rdata    | ((top->rvfi_rs1_rdata & 0x80000000) ? signExtension : 0 ),
        .rvfi_rs2_data = top->rvfi_rs2_rdata    | ((top->rvfi_rs2_rdata & 0x80000000) ? signExtension : 0 ),
        .rvfi_rd_wdata = top->rvfi_rd_wdata     | ((top->rvfi_rd_wdata & 0x80000000) ? signExtension : 0 ),
        .rvfi_mem_addr = top->rvfi_mem_addr     | ((top->rvfi_mem_addr & 0x80000000) ? signExtension : 0 ),
        .rvfi_mem_rdata = top->rvfi_mem_rdata   | ((top->rvfi_mem_rdata & 0x80000000) ? signExtension : 0 ),
        .rvfi_mem_wdata = top->rvfi_mem_wdata   | ((top->rvfi_mem_wdata & 0x80000000) ? signExtension : 0 ),
        .rvfi_mem_rmask = top->rvfi_mem_rmask,
        .rvfi_mem_wmask = top->rvfi_mem_wmask,
        .rvfi_rs1_addr = top->rvfi_rs1_addr,
        .rvfi_rs2_addr = top->rvfi_rs2_addr,
        .rvfi_rd_addr = top->rvfi_rd_addr,
        .rvfi_trap = top->rvfi_trap,
        .rvfi_halt = top->rst_i,
        .rvfi_intr = top->rvfi_intr
    };*/

    RVFI_DII_Execution_Packet execpacket = {
        .rvfi_order = 0,
        .rvfi_pc_rdata = top->out_rvfi_dii_data_rvfi_data_rvfi_pc_rdata,
        .rvfi_pc_wdata = top->out_rvfi_dii_data_rvfi_data_rvfi_pc_wdata,
        .rvfi_insn = top->out_rvfi_dii_data_rvfi_data_rvfi_insn,
        .rvfi_rs1_data = top->out_rvfi_dii_data_rvfi_data_rvfi_rs1_data,
        .rvfi_rs2_data = top->out_rvfi_dii_data_rvfi_data_rvfi_rs2_data,
        .rvfi_rd_wdata = top->out_rvfi_dii_data_rvfi_data_rvfi_rd_wdata,
        .rvfi_mem_addr = top->out_rvfi_dii_data_rvfi_data_rvfi_mem_addr,
        .rvfi_mem_rdata = top->out_rvfi_dii_data_rvfi_data_rvfi_mem_rdata,
        .rvfi_mem_wdata = top->out_rvfi_dii_data_rvfi_data_rvfi_mem_wdata,
        .rvfi_mem_rmask = top->out_rvfi_dii_data_rvfi_data_rvfi_mem_rmask,
        .rvfi_mem_wmask = top->out_rvfi_dii_data_rvfi_data_rvfi_mem_wmask,
        .rvfi_rs1_addr = top->out_rvfi_dii_data_rvfi_data_rvfi_rs1_addr,
        .rvfi_rs2_addr = top->out_rvfi_dii_data_rvfi_data_rvfi_rs2_addr,
        .rvfi_rd_addr = top->out_rvfi_dii_data_rvfi_data_rvfi_rd_addr,
        .rvfi_trap = top->out_rvfi_dii_data_rvfi_data_rvfi_trap,
        .rvfi_halt = top->reset,
        .rvfi_intr = 0
    };

    return execpacket;
}


